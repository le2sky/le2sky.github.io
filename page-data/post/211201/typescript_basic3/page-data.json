{
    "componentChunkName": "component---src-templates-post-template-tsx",
    "path": "/post/211201/typescript_basic3/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h3>1. 함수 매개변수 타입</h3>\n<p>tsconfig.json에 noImplicitAny 설정 값이 true 일 경우, 암시적인\r\nany 사용 시 오류가 난다.</p>\n<blockquote>\n<p>함수 매개변수에서만 해당사항이 있는것 같아보인다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//error! 암시적으로 id와 name 매개변수가 any로 지정되었음\r\nfunction foo(id, name) {\r\n  return { id, name }\r\n}\r\nlet obj = foo(1, &#39;leesky&#39;)\r\n\r\n//명시적으로 함수 매개변수 타입 사용 방법\r\nfunction foo(id: number, name: string) {\r\n  return { id, name }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>2. union 타입</h3>\n<p>id 매개 변수에 설정 가능한 타입 값을 number, string 모두 가능하게 하려면\r\n파이프(|) 를 사용하여 설정한다. 이를 유니온 타입이라고 한다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">function foo(id: number | string, name: string) {\r\n  return { id, name }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>3. 함수 리턴 타입</h3>\n<p>void 는 결과 값을 반환하지 않는 함수에 설정한다. 반면 결과 값을\r\n반환하는 함수는 명시적으로 반환값 타입을 지정할 수 있다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">function sayHi(name: string): void {\r\n  alert(`hello! ${name}!`)\r\n}\r\n\r\nfunction getDoubleNum(num: number): number {\r\n  return num * 2\r\n}\r\n\r\nfunction getStringNum(num: number): string {\r\n  return num.toLocaleString()\r\n}</code>\n        </deckgo-highlight-code>\n<br>\n<p>명시적으로 반환 값을 설정하지 않는 함수는 undefined를 반환하기에\r\nTypescript에서는 void를 명시한다.</p>\n<h3>4. 함수 식</h3>\n<p>변수에 함수 값을 할당하는 식은 컴파일 과정에서 오류를 발생시키지 않는다.</p>\n<blockquote>\n<p>직접 해본 결과 오류가 난다.</p>\n</blockquote>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let foo = function (name) {\r\n  alert(`hello ${name}`)\r\n}</code>\n        </deckgo-highlight-code>\n<br>\n<p>하지만 명시적으로 함수에 설정 가능한 타입을 정의하고자 하면\r\n다음과 같이 작성할 수 있다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//변수에 함수 매개변수, 리턴 타입에 대한 명시적 설정\r\nlet foo: (name: string) =&gt; void\r\n\r\n//대입하는 function 매개변수와 반환값 타입을 지정할 필요가 없음\r\nfoo = function (name) {\r\n  alert(`hello ${name}`)\r\n}</code>\n        </deckgo-highlight-code>\n<br>\r\n변수에 명시적 타입 설정, 함수 값 할당 구문을 별도로 안나누고 한번에 정의가능\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let foo: (name: string) =&gt; string = function (name) {\r\n  return `hello!! ${name}`\r\n}</code>\n        </deckgo-highlight-code>\n<br>\r\nES6 화살표 함수 식을 사용하면 다음과 같이 기술할 수 있다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let foo: (name: string) =&gt; string = name =&gt; {\r\n  return `hello!! ${name}`\r\n}</code>\n        </deckgo-highlight-code>\n<h3>5. Object 타입</h3>\n<p>typescript에서 변수에 초기 설정된 값을 암시적으로 할당 가능한 데이터 타입으로\r\n설정하기에 초기 설정된 값과 다른 형태로 할당될 경우 오류가 난다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//아래와 같이 선언되면 암시적으로 {name:string, age:number} 타입으로 지정됨\r\nlet obj = {\r\n  name: &#39;leesky&#39;,\r\n  age: 23,\r\n  sayHi(name) {\r\n    alert(`hello! ${name}`)\r\n  },\r\n}\r\n\r\n/* 아래와 같이 재할당 해버리면 에러남~~~\r\nobj = {\r\n  n: &#39;leesky&#39;,\r\n  a:23,\r\n  sayHello(){\r\n    alert(&#39;hello!&#39;);\r\n  }\r\n}\r\n\r\nobj = {\r\n  name: 23,\r\n  age: &#39;leesky&#39;,\r\n  } \r\n}\r\n\r\n*/</code>\n        </deckgo-highlight-code>\n<br>\r\n객체의 각 속성 타입을 명시하려면 아래와 같이 하면 된다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let obj: {\r\n  name: string\r\n  age: number\r\n  sayHi: (name: string) =&gt; void\r\n} = {\r\n  name: &#39;leesky&#39;,\r\n  age: 23,\r\n  sayHi(name) {\r\n    alert(`hello! ${name}`)\r\n  },\r\n}</code>\n        </deckgo-highlight-code>\n<br>\r\n하지만 타입으로 설정되지 않은 객체의 속성을 새롭게 추가할 경우\r\n에러가 난다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">// error!\r\nobj.newFunction = function () {}</code>\n        </deckgo-highlight-code>\n<br>\r\n새롭게 추가할 newFucntion 프로퍼티를 타입에 추가하면 되지만,\r\n매번 하기에는 번거롭다. 따라서 아래와 같이 하면 쉽게 프로퍼티를\r\n추가할 수 있다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let obj: {\r\n  name: string\r\n  age: number\r\n  sayHi: (name: string) =&gt; void\r\n  [propName: string]: any // &lt;-- 이런 식으로 아무 속성을 추가할 수 있도록함\r\n} = {\r\n  name: &#39;leesky&#39;,\r\n  age: 23,\r\n  sayHi(name) {\r\n    alert(`hello ${name}`)\r\n  },\r\n}\r\n\r\nobj.newFunction = function () {\r\n  return &#39;it is work!&#39;\r\n}</code>\n        </deckgo-highlight-code>\n<h3>6. null / undefined 타입</h3>\n<p>Javascript에서 null, undefiend도 데이터 타입이자 하나의 값으로 취급된다.\r\nTypescript에서도 하나의 타입으로 처리되며 다음과 같이 사용한다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let nullable: null = null\r\nlet undefinedabe: undefined = undefined</code>\n        </deckgo-highlight-code>\n<br>\r\n하지만 null로 명시적 타입이 설정된 변수에 null이 아닌 값이 할당되면\r\n오류가 난다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//error!\r\nnullable = undefined</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>tsconfig.json에 strictNullChecks가 true면 모든 데이터 타입은 null, undefiend를 할당 받을 수 없다. false면 null이나 undefined 가능</p>\n</blockquote>\n<p>이러한 문제를 해결하기위해서는 any 타입이나 유니온 타입을 사용할 수 있는데\r\n타입검사를 위해서는 유니온 타입을 쓰는게 적절할 것이다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let assign_name: string | null = null //가능\r\nif (!assign_name) {\r\n  assign_name = &#39;leesky&#39;\r\n}</code>\n        </deckgo-highlight-code>\n<h3>7. never 타입</h3>\n<p>never는 일반적으로 함수 리턴 타입으로 사용된다. nerver 은 함수의 끝에 도달\r\n할 수 없다는 뜻이며, 함수의 리턴 타입으로 never 가 사용된 경우에는, 항상\r\n오류를 출력하거나 리턴 값을 절대 내보내지 않는 다는 뜻이다. (무한 루프)</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//항상 오류 발생\r\nfunction invalid(message:string): never{\r\n  thorw new Error(message);\r\n}\r\n\r\n// never 타입 추론\r\nfunction fail(){\r\n  return invalid(&#39;실패!&#39;);\r\n}\r\n// 무한 루프\r\nfunction infiniteAnimate(): never{\r\n  while(true) { infiniteAnimate() }\r\n}\r\n</code>\n        </deckgo-highlight-code>\n<br>\r\nnever 타입을 지정한 변수에 never가 아닌 타입은 할당할 수 없다.\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let neverType: never\r\n// error! never 타입에 number 할당 불가\r\nneverType = 123\r\n\r\n// 함수의 반환값이 never 타입이기 때문에 오류안남!\r\n// 이 경우는 조금 특이한데, 함수의 반환값이 익명 never 반환 함수이기\r\n// 때문에 throw new Error을 만나서 never 타입의 무언가를 반환하나보다.\r\nneverType = (function (): never {\r\n  throw new Error(&#39;Error&#39;)\r\n})()</code>\n        </deckgo-highlight-code>\n<h3>8. 사용자 정의 타입</h3>\n<p>복잡한 타입을 매번 설정하는 것은 상당히 번거롭다.\r\n복잡한 타입을 사용자 정의하여 재사용하기 용이하도록 typescript는 지원한다.\r\n타입 별칭(type alias)을 정의 하려면 type 키워드를 사용한다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">//너무 복잡하고 재사용하기도 힘들다!\r\nlet user: {\r\n  name: string\r\n  age: number\r\n  isAdmin: boolean\r\n  family: string[]\r\n} = {\r\n  name: &#39;leesky&#39;,\r\n  age: 23,\r\n  isAdmin: true,\r\n  family: [&#39;daddy&#39;, &#39;mammy&#39;, &#39;sister&#39;],\r\n\r\n//재사용하기도 쉽고 가독성도 좋다.\r\ntype userType= {\r\n  name: string,\r\n  age: number,\r\n  isAdmin: boolean,\r\n  family: string[],\r\n  sayHi: (name: string) =&gt; void\r\n\r\n}\r\n\r\nlet user:userType = {\r\n  name: &#39;leesky&#39;,\r\n  age: 23,\r\n  isAdmin: true,\r\n  family: [&#39;daddy&#39;, &#39;mammy&#39;, &#39;sister&#39;],\r\n  sayHi(name){\r\n    alert(`hello! ${name}`)\r\n  }\r\n}</code>\n        </deckgo-highlight-code>\n<h3>9. 타입 단언(Assertion)</h3>\n<p>Typescript 프로그래밍을 하다보면 타입 어설션(단언, Assertion)을 사용해야\r\n하는 순간이 온다. 타입 단언은 컴파일러에게 “이 타입이 특정 타입 임을 단언한다”\r\n라고 말하는 것과 같다.</p>\n<blockquote>\n<p>컴파일러보다 타입을 더 잘알고 있는 경우 타입 단언을 한다!</p>\n</blockquote>\n<p>다른 언어의 타입 캐스트(Cast)와 비슷하지만, <strong>특별한 검사나 데이터 재구성을\r\n수행하지 않는다</strong>. 런타임 시, 영향을 미치지 않으며 오직 컴파일 과정에서만 사용된다. 타입 단언을 처리하는 방법은 2가지이다.</p>\n<ol>\n<li>앵글 브라켓 <code>&#x3C;></code>문법을 사용하기</li>\n</ol>\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let assertion: any = &#39;leesky&#39;\r\n// assertion 변수의 타입을 &lt;string&gt;으로 단언한다.\r\n// assertion string 타입임\r\nlet assertion_count: number = (&lt;string&gt;assertion).length</code>\n        </deckgo-highlight-code>\n<br>\r\n2. `as` 문법 사용하기\n<deckgo-highlight-code language=\"ts\" theme=\"material\"  >\n          <code slot=\"code\">let assertion: any = &#39;leesky&#39;\r\n// as를 통해 assertion 을 string으로 단언\r\nlet assertion_count: number = (assertion as string).length</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>타입 단언은 타입 캐스트와 비슷하지만, 특별한 검사, 데이터 재구성을 안한다\r\n는 점에 주목하자. 그리고 추가적으로 JSX 에서는 as 문법만 사용할 수 있다.</p>\n</blockquote>\n<h4>참고</h4>\n<ul>\n<li><a href=\"https://yamoo9.gitbook.io/typescript/\" target=\"_blank\" rel=\"nofollow\">Typescript 가이드북</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#1-%ED%95%A8%EC%88%98-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85\">1. 함수 매개변수 타입</a></p>\n</li>\n<li>\n<p><a href=\"#2-union-%ED%83%80%EC%9E%85\">2. union 타입</a></p>\n</li>\n<li>\n<p><a href=\"#3-%ED%95%A8%EC%88%98-%EB%A6%AC%ED%84%B4-%ED%83%80%EC%9E%85\">3. 함수 리턴 타입</a></p>\n</li>\n<li>\n<p><a href=\"#4-%ED%95%A8%EC%88%98-%EC%8B%9D\">4. 함수 식</a></p>\n</li>\n<li>\n<p><a href=\"#5-object-%ED%83%80%EC%9E%85\">5. Object 타입</a></p>\n</li>\n<li>\n<p><a href=\"#6-null--undefined-%ED%83%80%EC%9E%85\">6. null / undefined 타입</a></p>\n</li>\n<li>\n<p><a href=\"#7-never-%ED%83%80%EC%9E%85\">7. never 타입</a></p>\n</li>\n<li>\n<p><a href=\"#8-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%ED%83%80%EC%9E%85\">8. 사용자 정의 타입</a></p>\n</li>\n<li>\n<p><a href=\"#9-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8assertion\">9. 타입 단언(Assertion)</a></p>\n<ul>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Typescript 기본기 다지기(3)","summary":"Typescript function, union, void, object, null, underined, never, 사용자정의 타입, 타입단언 알아보기!","date":"2021.12.01.","categories":["Typescript"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#3878c8","images":{"fallback":{"src":"/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/5371e/typescript.png","srcSet":"/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/24271/typescript.png 56w,\n/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/39d80/typescript.png 113w,\n/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/5371e/typescript.png 225w","sizes":"(min-width: 225px) 225px, 100vw"},"sources":[{"srcSet":"/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/d66a6/typescript.webp 56w,\n/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/a72fd/typescript.webp 113w,\n/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/1cf63/typescript.webp 225w","type":"image/webp","sizes":"(min-width: 225px) 225px, 100vw"}]},"width":225,"height":225}},"publicURL":"/static/ae9e22bc0023fde9b3e0c6fce9db0f0a/typescript.png"}}}}]}},"pageContext":{"slug":"/post/211201/typescript_basic3/"}},
    "staticQueryHashes": []}